# STOPLIGHT-GAME

Description: 

  The project I will be designing and demonstrating will be based on a popular arcade game: stoplight. The goal of the game is to stop a circulating light on the correct bulb by pressing a button. This project was approved by Professor Ken Arnold as it satisfies the minimum requirements for a student project. This project will be designed using two modules. The main module will include all the necessary code that designs each aspect of the game completely. The second module will be responsible for displaying numbers on the 7-segment display. The main module will be used to design the counters and LEDs and design statements that will create the game. Professor Arnold gave us a lot of freedom and flexibility on our project and the methods we can choose to design it.

  To design the necessary features for this game, I needed to implement the BASYS’s constraints file. This would allow me to utilize the buttons, LEDs, and segment displays used for the game. I then implemented the necessary registers that will be needed to design the counter. This counter will help me circulate through the LEDs at different rates that I will specify. The rate of the circulating lights will increase as the user progresses through the rounds of the game. The game will consists of 3 rounds of which the user will need to stop the circulate light on a specific LED. If the user successfully stops the light on the correct LED for each of the 3 rounds then the user has beaten the game. If the user fails on any round, the game will restart from the first round if the user chooses to play again. 
  
User Instructions:

1.	By default, the game will start off in idle mode which continues forever until the user presses the center button. This will begin the game.
2.	After the center button has been pressed, the user will need to attempt to stop the circulating light on the LED specified by the segment display by pressing the right button to stop the light. If the user manages to stop it correctly, then they will progress to the next round. If the user fails, it will reset back into idle mode.
3.	After 3 successive entries, all LEDs will blink on and off indefinitely signifying you won and will then reset back into idle mode once the left button is pressed. 


Module 1: stoplightGame

The first module is the main module that is used to design this game. The first thing I did was declare the correct inputs and outputs for my BASYS board. I declared the clk and buttons as inputs and the segment display, an, and LEDs as outputs. The first registers I declared were the startFlag and the playingFlag. These flags will either by 0 or 1, based on whether or not the user is starting the game or already playing the game. Just after is a register named reset that will reset the counter and blink to 0. These 3 registers will control the logic of my case statement. The main block of my code will be a case statement that will be responsible for designing each round of the game. I then created numerous parameters that will be used in naming my states and to help light up the display segment and make the code easier to read and understand. I then created a three counter registers that will be used individually for each of the three rounds. The purpose of these counters are to control the rate of the circulating LEDs, with each round causing the LEDs to circulate quicker. I then create a 4-bit register x and y which will be used in blinking on the necessary LEDs. Just before I get to the switch case statement that controls the function of the game, I instantiate my SegmentDisplay module which will allow me to utilize two of the four segment displays on the board.

	After instantiating the 2nd module, I proceed to setup the first always block. This always block will trigger each time on the rising edge of the clock. Inside this block begins a switch case statement that controls the states of my game. The game will start in ‘idle’ mode which prompts the user to press the center button to start the game. During this mode, the even and odd lights will alternate blinking and the segment display will show double zero on the 1st and 4th segment to signify that it is in awaiting user input. Once the user presses the center button, the state will move from idle to ‘pattern1’. Pattern 1 state will then show the integer 8 on the left-most segment on the display. This will show which LED user will try to stop the circulating lights on. To circulate the lights, I created a counter that counts up to 1/8th of a second. Every 1/8th of a second, an LED will flash on and the previous LED next to it will flash off. The else-statement will then reset the counter and increment the flashing-on LED and the flashing-off LED. When either of these flashing LEDs reach 16, they will both reset back to 0. I then coded the 4th segment of the display to notify which round the user is on. In pattern1, it will show ‘1’ and in pattern 2, it will show ‘2’, etc. 
  
	Pressing the right button will stop the circulating LED on the current LED number that was lit. If the LED number was 8, it will proceed to a ‘victory’ state which will blink all the LEDS 3 times before proceeding to ‘pattern2’. Pattern 2 and pattern 3 have the same logic as pattern1, but with different circulating speeds at 1/16th of a second and 1/24th of a second. Beating the ‘pattern2’ state will go back to the victory state, but an if-else statement will prevent it from looping back to itself and instead move to ‘pattern3’. If the user at any point stops the LED on a number different than 8, the game will blink that number and 3 times and return back to the ‘idle’ state. If the user manages to successfully stop on the 8th LED 3 times in a row, you will then be in the ‘finish’ state and the segment display will show that you have reached the 4th stage which symbolizes you have beaten the game. All LEDs will flash on and off indefinitely until you press the left button to return to the idle state, where the user can play again. 

Module 2: SegmentDisplay

  The second module that is being instantiated in the main module is responsible for displaying the two numbers in the segment display. It is nearly similar to the segment display code used in the digital clock assignment, but instead only uses 2 segments instead of all 4. First I start by creating the necessary inputs and outputs. Input3, Input0, and clk are my inputs and my outputs are an and seg. I then create a counter and a parameter named max set to 10000 that the counter will count to before resetting. The other registers are a 1-bit ‘currentan’ register that signifies the current placement of the segment display. I then create 2-elemnt, 8-bit register called ‘segoutput’ that represents the patterns to create the numbers 0-9 on the segment display. Last, I create a 2-element, 4-bit wire that called ‘twodisplay’ that will assigned to our inputs: input3 and input0. Parameters are then used to label the number patterns for the 7-bit codes to display the numbers on the board.

  Next, I create an always@ block that triggers on the rising edge of the clock. Inside the block is a counter that increments itself to max before resetting itself to repeat. Each time it reaches max, the counter will reset and it will switch between the current segment display by assigning currentan to the negation of itself. Next, is a case statement with its variable being dependent on the twodisplay at the alternating currentan register. This will be responsible for displaying the correct patterns of the 7-segments to represent a number. A second case will then be used with its variable being dependent at the currentan which represents either the first or fourth segment display. This case statement will activate the correct segment display, either the first or fourth, then assign the pattern from the previous case statement to the seg, ultimately displaying the number on the display.
